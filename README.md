# state_tomo_coverage
## Author: Samuel Showalter
### Date: June 5, 2018

# Quantum State Tomography Coverage Simulation Package.
This software package simulates quantum state tomography in an effort
to better understand optimal estimation and coverage methods. Given 
density matrix `Rho`, this package will simulate measurements from that density matrix. From those measurement, it will estimate that density matrix and give confidence intervals for fidelity and purity via bootstrapping. A main goal of this project is to test the actual coverage probabilities of various methods to construct confidence intervals, so this package will repeatedly simulate measurements on the given state, construct many confidence intervals from each simulated experiment and report the frequency with which a confidence interval construction method actually contains the true state. More information about the code is included below and broken out by package. Future plans for this distribution include implementing tools to import and analyze experimental data and for analyzing systems larger than a single qubit.

The true state `Rho` is a given pure state `rho_goal` that has been perturbed by given level of depolarizing noise `noise_perc`. The package computes confidence intervals for the fidelity between `Rho` and `rho_goal` and for the purity of `Rho`.

The implemented confidence intervals are all based on parametric bootstrap methods, so the package contains infrastructure for generating and recording bootstrap datasets generated by simulating measurements from an initial estimate `rho_hat`. 


# Getting Started

## Dependencies:

All dependencies listed have an easy install method via either `pip` or `conda`.

 - numpy
 - pandas
 - scipy
 - progressbar

## Classes

Several classes coordinate the execution of quantum state tomography.

 - QST_sim
 - measurement_sim
 - confidence_intervals
 - logger
 - rho_estimator
     + linear_inversion
     + diluted_mle
 
### Package Class UML Diagram

<p align="center"><img src="https://image.ibb.co/h2UR9o/Class_Diagram_QST.png" alt="Class_Diagram_QST" width="800" height="800"/>

The class diagram for these objects is outlined above. `QST_sim` objects represent an orchestration of all other objects. Essentially, if someone wants to conduct a top-to-bottom analysis with this package, they must create a `QST_sim` object with the desired parameters. QST_sim objects take `MeasSim`, `Solver`, `Logger`, and optional `Coverage` objects as its inputs. Each of these classes is discussed below.

Shown below in the **Execution Process Diagram**, the measurement_sim, or MeasSim, class is first called during the execution. One supplies a `rho_goal` as well as additional parameters. A `rho_true` density matrix is created, from which several measurements are taken with different measurement operators, or POVM elements. All of these observations are stored as frequency measurements in an array.

From here, the `rho_estimation` or `RhoEst` class takes this measurement data and uses a solver specified in the `QST_Sim` object -- either `LinearInversion` or `DilutedMLE` -- to estimate a `rho_hat` that may closely represent the initial `rho_goal`. Linear inversion<sup>1</sup> and Diluted Maximum Likelihood<sup>2</sup> (MLE) optimization operate in different ways, but both are dynamically called by `RhoEst` and return the same information (with the exception of some metadata disparities). From these solvers, a rho_hat estimate is returned. Additional metrics about this estimate, including purity and fidelity with `rho_goal`, are calculated and stored.

Upon the creation of a `rho_hat` estimate, the package returns to the `MeasSim` object to again collect measurement data, though this data is calculated assuming `rho_hat` is `rho_true`, making all additional experiments bootstrapped samples. A specified number of datasets, proportional to the number of bootstrapped estimates desired, are created. This data is passed to the `RhoEst` class, which then calculates estimates for each bootstrap sample using the same solver implemented for the initial `rho_hat`. All bootstrapped rho estimates are collected, as are fidelities and other analytical measurements. 

Arrays filled with the fidelity and purity measurements of bootstrapped sample estimates is passed to the `Coverage` object, which calculates confidence intervals of different types. All of the data calculated and collected throughout this execution is either stored in the `MasterLog` or the `BootLog`, both of which are `Logger` objects. Once the coverage intervals are made and the data has been logged, the execution terminates.

### Execution Process Diagram
<p align="center"><img src="https://image.ibb.co/ivogKT/Process_Diagram_Final.png" alt="Process_Diagram_Final" width="900" height="500"/>

# Features
- Measurement simulation for quantum state tomography in different bases specified by the user.
    + Eventually, this package will be compatible with flat file experimental data.
- Rho estimation for both bootstrapped and non-bootstrapped samples.
    + Rho can be estimated with either LinearInversion or DilutedMLE solvers
- Confidence interval creation via a variety of methods. 
- Full logging of all execution metadata, and different levels of granularity. These levels are listed below.
    + Master Log: Low granularity; overview of entire test
    + Boot Log: Medium granularity; bootstrap information from a single execution
    + Verbose Log; High granularity; MLE execution metadata for a specific bootstrap sample.

Below, each package is explained with a high level of detail such that their parameters and interaction with other packages is clearly understood.

### `QST_sim`.QSTSim(
                meas_sim, 
                solver, 
                log, 
                coverage = None):

Initialize and run an entire quantum state tomography test. If one wishes to be able to replicate the experiment, seed the random number generator with `np.random.set_seed()` before ANY execution begins. These seeds will be logged during the execution.

#### Parameters:
- **meas_sim**: MeasSim object from class `measurement_sim`. 
- **solver**: Solver object from either the `linear_inversion` or `diluted_mle` class.
- **log**: Log object from class `logger`. Used here as a Master Log.
- **coverage**: Defaulted to None, the Coverage object is from class `coverage` and generates confidence intervals from bootstrapped fidelity. estimates. If it is set to None, then no coverage intervals are calculated.

### `measurement_sim`.MeasSim(
                rho_goal, 
                noise_perc, 
                initial_rho_hat_trials, 
                rho_sub_experiments, 
                rho_sub_trials, 
                tol = 1e-7,  
                measurement_ops = np.matrix(#Computational basis
                                            [np.array([1, 0, 0, 0]),
                                             np.array([0, 0, 0, 1]),

                                             #Right left basis
                                             0.5*np.array([1, 1, 1, 1]),
                                             0.5*np.array([1, -1, -1, 1]),

                                             #Plus- minus basis
                                             0.5*np.array([1, 0+1j, 0-1j, 1]),
                                             0.5*np.array([1, 0-1j, 0+1j, 1])]
                                            )):

Measurement package that collected observational data and stores all information in frequency arrays. This data is later used by the `rho_estimation` package to estimate rho.

#### Parameters:
- **rho_goal**: n x n matrix representing the mixed or pure state of one or more qubits. Must be in `np.matrix()` format.
- **noise_perc**: Float from [0,1] that represents the amount of noise applied to rho_goal to create rho_true. Rho_true is created as the linear combination of rho_goal and the maximially mixed state; noise_perc provides the coefficients for this linear combination.
- **initial_rho_hat_trials**: Number of measurements made and then used to calculate the initial rho_hat. Bootstrap samples will utilize rho_hat as its de-facto rho_true.
- **rho_sub_experiments**: Number of sub-experiments to be run. Each sub-experiments generates a dataset similar to the original data set, except that its measurements are simulated using `rho_hat`. `rho_sum_experiments' is the number of bootstrap estimates created. If no bootstrapping or confidence intervals are needed, this value should be set to zero.
- **rho_sub_trials**: Number of measurements made and then used to calculate bootstrapped rho_hat estimates.
- **tol**: Tolerance level for imaginary numbers. Can occur due to rounding errors in Python's floating point precision. Default set at 1e-7.
- **measurement_ops**: Measurement operators (POVM elements) used to observe different quantum states in different bases. Default set to the operators of the computational, X-Y, and Plus-Minus basis.

### `rho_estimation`.RhoEst(
                measurement_sim, 
                solver = LinearInversion()):

Package that estimates rho dynamically using one or multiple optimization packages. Metadata and estimations from the execution are stored for both initial rho_hat and bootstrap estimates. This class also calculates fidelity, purity, and likelihood for other estimates.

#### Parameters:
- **measurement_sim**: MeasSim object that contains all measurement data in the form of measurement frequency arrays.
- **solver**: Solver object (from either `linear_inversion` or `diluted_mle`) that is used to estimate rho_hat. Default set to LinearInversion().

### `linear_inversion`.LinearInversion():

Rho estimation solver package that analytically calculates rho_hat via linear inversion. 

#### Parameters:
- **RhoEst**: Provided by the QSTSim shell object. Includes all rho estimator data.
             
### `diluted_mle`.DilutedMLE(
                stopping_crit = 1e-10,
                iter_bound = 50000,
                verbose_exp = []):

Rho estimation solver package that determines a rho_hat estimate by implementing Diluted MLE R-rho-R optimization. Returns a rho_hat estimate as well as metadata that can be stored in a `VerboseLog`.

#### Parameters:
- **RhoEst**:Provided by the QSTSim shell object. Includes all rho estimator data.
- **stopping_crit**<sup>3</sup>:  Threshold for stopping execution. When the upper bound becomes smaller than the criteria, stop the execution.
- **iter_bound**: Threshold for RrhoR optimization timeout. If the number of iterations exceeds this amount, the execution will halt.
- **verbose_exp**: List of indices as integers. A verbose log of MLE execution metadata will be collected for the experiment corresponding to those indices.

### `confidence_intervals`.Coverage(
                confidence = 0.95,
                interval_type = "all"
                sided = "two_sided",
                method = "all"):

Coverage package that creates one or more confidence intervals for rho_hat fidelity using bootstrapped fidelity calculations derived from bootstrap rho_hat estimates. Fidelity is calculated between `rho_goal` and rho_hat estimates.

#### Parameters:
- **RhoEst**:Provided by the QSTSim shell object. Includes all rho estimator data.
- **confidence**: Level of confidence for the given interval. Specified as a float in the range [0,1].
- **interval_type**: Determines what type of data is used to build CI. Options are the set {`"all"`, `"fidelity"`, `"purity"`}. 
- **sided**: Side of the confidence interval. Options are the set {`"two_sided"`,`"upper"`,`"lower"`}.
- **method**: Method for constructing the confidence interval. Setting this parameter to `"all"` will generate all confidence intervals. Otherwise, specific intervals can be set by specifying a keyword from the following set<sup>4</sup>: {`"percentile"`,`"normal"`,`"basic"`,`"bias_corrected"`,`"BC_a"`}.


### `logger`.Log(
                master_log_name, 
                boot_log_name, 
                verbose_log_name):

Logger object that stores and organizes all data from an execution. One instantiation of a Log can be a Master Log, Boot Log, or Verbose Log, but not more than one at once. All logs are organized using transferrence of file names and folders named accordingly. Logger names for the Boot Log files are of the format `sV_W_nX_tY_Z_hh.mm.ss.fff` where `V` is the random seed of the execution (or left blank if there is none), `W` is the solver method, `X` is the noise percentage of the sample, `Y` is the number of trials for the initial rho_hat, and `Z` is the given boot log name. The last characters are a time stamp down to the thousandth of a second. Verbose Log filenames are of the format `Z_hh.mm.ss.fff` where `Z` is the Verbose Log name and the timestamp is to the thousandth of a second. 

#### Parameters:
- **master_log_name**: Master Log name. Time stamps and other features are added to these names to ensure the file is unique and does not override other data.
- **boot_log_name**: Boot log name. Saved in a folder with a name corresponding to the relevant Master Log.
- **verbose_log_name**: Verbose log name. Saved in a folder with a name corresponding to the relevant Boot Log.  

# Outputs

The output after runtime is a `QST_Sim` object which contains all the data from the execution. However, generally direct examination of this object is not necessary. The logger objects pertaining to the execution save .csv files of all the important metadata in a user-friendly manner. For example, a single row in a `MasterLog` corresponds to an entire `QST_Sim` execution. However, in a folder named after the master log, several `BootLog` files will likely exist. One `BootLog` file pertains to a single `QST_sim` execution, and contains granular data on the bootstrapped samples.

# Citations:
1. Max S. Kaznady and Daniel F. V. James, "Numerical strategies for quantum tomography: Alternatives to full optimization" [Phys. Rev. A 79, 022109 (2009)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.79.022109), [arXiv:0809.2376](https://arxiv.org/abs/0809.2376).

2. Jaroslav Rehacek, Zdenek Hradil, E. Knill, and A. I. Lvovsky, "Diluted maximum-likelihood algorithm for quantum tomography" [Phys. Rev. A 75, 042108 (2007)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.75.042108), [arXiv:quant-ph/0611244](https://arxiv.org/abs/quant-ph/0611244).

3.  S. Glancy, E. Knill, and M. Girard, "Gradient-based stopping rules for maximum-likelihood quantum-state tomography" [New Journal of Physics 14, 095017](https://doi.org/10.1088/1367-2630/14/9/095017), [arXiv:1205.4043](https://arxiv.org/abs/1205.4043).

4. James Carpenter and John Bithell "Bootstrap confidence intervals: when, which, what? A practical guide for medical statisticians" [Statist. Med. 19, 1141 (2000)](https://doi.org/10.1002/(SICI)1097-0258(20000515)19:9%3C1141::AID-SIM479%3E3.0.CO;2-F).

# Example

Below is a demonstration on how one might run a QST_Sim tomography experiment using this package. 

```
MasterLog1 = MasterLog("Master_Log","Boot_Log","Verbose_Log")

test1 = QSTSim( MeasSim(#Rho_goal
                        np.matrix([[0.5,-0.5j],
                                   [ 0.5j,0.5]]),

                        #Noise_perc
                        0.0,

                        #initial rho hat trials
                        10000,

                        #Rho sub_experiments
                        100,

                        #sub_experiment trials
                        10000),

                        #Solver(s)
                        [LinearInversion(), DilutedMLE()],

                        #Log reference to master log
                        log = MasterLog1,

                        #Coverage defaults to none
                        coverage = Coverage())
```

This test examines the Pauli-Y basis state as a pure state (noise_perc = 0.0). It first conducts 10,000 measurements and then uses both Linear Inversion and Diluted MLE solvers to generate separate estimates of the initial rho_hat. This rho_hat is then incorporated to generate measurement samples of size 10,000 for 100 bootstrap experiments. Again, all bootstrapped samples will be estimated with both Linear Inversion and Diluted MLE optimization.

The coverage package then runs and creates a confidence interval using all of the available methods (default = "all") and data types (default = "all" = ["fidelity", "purity"]). This information, as well as all the other information from the test, is stored in MasterLog1.

# Installation
You may obtain the software from
[https://github.com/usnistgov/state_tomo_coverage](https://github.com/usnistgov/state_tomo_coverage).

The software was written for Python 3. To create a Python 3 environment,
we recommend using [Anaconda](https://www.anaconda.com/download/). 

For more information and instructions see [Conda's User Guide](https://conda.io/docs/user-guide/tasks/manage-environments.html)

All three scripts mentioned above can be run from the terminal, a Python Shell, or a developement environment like Spyder 
(included with Anaconda).

# Support
If you are having issues, please contact [Scott Glancy](mailto:sglancy@nist.gov).